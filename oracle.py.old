#!/usr/bin/env python
#coding=utf-8

'''
Definition of Oracle class. Given information related to the gold AMR relations
and the current state (including alignment information), it decides which action
should be taken next.

@author: Marco Damonte (s1333293@inf.ed.ac.uk)
@since: 23-02-13
'''

from action import Action
from relations import Relations
from node import Node
import copy
import codecs
from collections import defaultdict
import numpy
from graphlet import Graphlet
import cPickle as pickle

class Oracle:
	# forg = open("organizations.txt","w")
	table = {}

	@staticmethod
	def printTable():
		table2 = {}
		for token in Oracle.table:
			lst = Oracle.table[token]
			maxcounts = 0
			maxitem = None
			for item in lst:
				counts = lst.count(item)
				if maxcounts < counts:
					maxcounts = counts
					maxitem = item
			table2[token] = (maxitem,maxcounts)
		return table2

	# tcount = defaultdict(int)
	# gcount = defaultdict(int)
	# tgcount = defaultdict(int)

	# @staticmethod
	# def subgraphTable():
	# 	tokens = Oracle.tcount.keys()
	# 	subgraphs = Oracle.gcount.keys()
		# pickle.dump(tokens, open("resources/tokens.p", "wb"))
		# pickle.dump(subgraphs, open("resources/subgraphs.p", "wb"))
		# givent = numpy.zeros((len(tokens),len(subgraphs)))
		# giveng = numpy.zeros((len(tokens),len(subgraphs)))
		# for i, token in enumerate(tokens):
		# 	for j, subgraph in enumerate(subgraphs):
		# 		givent[i,j] = Oracle.tgcount[(token,subgraph)] / float(Oracle.tcount[token])
		# 		giveng[i,j] = Oracle.tgcount[(token,subgraph)] / float(Oracle.gcount[subgraph])
		# 		print token, subgraph
		# pickle.dump((givent,giveng), open("resources/subgraphtable.p", "wb"))

	def __init__(self, relations, atleastreduce = False):
		self.atleastreduce = atleastreduce
		self.gold = Relations(copy.deepcopy(relations))

	def valid_actions(self, state):
		top = state.stack.top()
		if state.stack.isEmpty() == False and len(self.gold.children[top]) == 0 and len(self.gold.parents[top]) == 0:
			return Action("reduce")
	
		else:
			for k in range(1, state.stack.depth):
				for (child, label) in self.gold.children[top]:
					if child == state.stack.get(k):
						self.gold.children[top].remove((child,label))
						self.gold.parents[child].remove((top,label))
						return Action("lrel",[k, label])


			for k in range(1, state.stack.depth):
				for (child, label) in self.gold.parents[top]:
					if child == state.stack.get(k):
						self.gold.parents[top].remove((child,label))
						self.gold.children[child].remove((top,label))
						return Action("rrel",[k, label])

		if state.buffer.isEmpty() == False:
			token = state.buffer.peek()
			nodes = token.nodes
			relations = []
			flag = False
			for n1 in nodes:
				for n2 in nodes:
					if n1 != n2:
						children_n1 = copy.deepcopy(self.gold.children[n1])
						for (child,label) in children_n1:
							if child == n2:
								relations.append((n1,n2,label))
								self.gold.children[n1].remove((child,label))
								self.gold.parents[child].remove((n1,label))
						children_n2 = copy.deepcopy(self.gold.children[n2])
						for (child,label) in children_n2:
							if child == n1:
								relations.append((n2,n1,label))
								self.gold.children[n2].remove((child,label))
								self.gold.parents[child].remove((n2,label))
			graphlet = Graphlet(nodes, relations)
			# Oracle.gcount[subgraph] += 1
			# Oracle.tcount[token.word] += 1
			# Oracle.tgcount[(token.word, subgraph)] += 1
			if nodes != []:
				# if token.ne == "ORG":
				# 	Oracle.forg.write(token.word + " " + nodes[0].concept + "\n")
				# tok = copy.deepcopy(token)
				# tok.index = 0
				# tok.nodes = None
				tok = token.word+"_"+token.pos
				if tok not in Oracle.table:
					Oracle.table[tok] = []
				Oracle.table[tok].append(graphlet)

			return Action("shift", [graphlet])
		
		if self.atleastreduce and state.stack.isEmpty() == False:				
			return Action("reduce")	
		return None